# go-dws JSCodeGen (and LLVM-ready) â€” Implementation Plan

## Phase 0 â€” Minimal setup & conventions (compiler exists, skip most scaffolding)

**CI Status**: Your project already has excellent CI coverage! Here's what's present vs needed:

**âœ… Already Present:**

- GitHub Actions with test, build, lint jobs across Go 1.24.x/1.25.x
- Comprehensive golangci-lint config (errcheck, govet, staticcheck, unused, etc.)
- Code coverage reporting to Codecov
- Go module and build caching
- go vet and go fmt checks

**ðŸ”§ Codegen-Specific Additions Needed:**

- Node.js runtime for executing generated JS code in tests
- Golden test framework for snapshot testing (MIR dumps, JS output)
- Optional: LLVM tools for future LLVM backend validation

- [ ] Adapt existing structure for codegen
  - [ ] `mir/` package (target-neutral IR, alongside existing `ast`/`types`)
  - [ ] `codegen/` package (shared codegen interfaces and utilities)
  - [ ] `codegen/js/` subpackage (JS backend implementation)
  - [ ] `codegen/ll/` subpackage (LLVM backend skeleton)
  - [ ] `runtime/` package (shared runtime API definitions)
  - [ ] `internal/testdata/` (golden DWScript inputs & expected outputs)
- [ ] Decide naming & formatting
  - [ ] **Package names**: `mir`, `codegen`, `runtime` (following existing lowercase convention like `ast`, `types`, `interp`)
  - [ ] **Type names**: UpperCamelCase (e.g., `Function`, `Block`, `Emitter`, `Builder`)
  - [ ] **Exported APIs**: UpperCamelCase functions/types (e.g., `NewBuilder()`, `EmitCode()`)
  - [ ] **Internal helpers**: lowerCamelCase (e.g., `emitLine()`, `addBlock()`)
  - [ ] **Generated code banner**: `// Code generated by go-dws; DO NOT EDIT.`
  - [ ] **CLI commands**: `build`, `dump-mir`, `compile-js` (following existing pattern: `lex`, `parse`, `run`)
- [ ] CI setup extensions (âœ… basic CI exists, add codegen-specific features)
  - [ ] **NEW**: Node.js setup for running generated JS code
  - [ ] **NEW**: Golden test framework for MIR/JS snapshots
  - [ ] **NEW**: Optional: LLVM tools cache for future LLVM backend

## Phase 1 â€” Define a target-neutral MIR (typed, SSA-ish)

- [ ] MIR core types (mir/)
  - [ ] Type system: Bool, Int{8,16,32,64}, Float{32,64}, String, Array(T), Record, Class, Pointer(T), Void
  - [ ] Value identity: ValueID, BlockID, symbol names
  - [ ] Functions: Func{ Name, Params, Ret, Blocks }
  - [ ] Blocks & control flow: Block{ Ops, Term } with Term = Br|CondBr|Return|Throw
  - [ ] Ops set (minimal first): Const, Phi, Add/Sub/Mul/Div/Rem, Cmp, Not/And/Or, Call, Alloca (front-only), Load/Store (if needed), NewArray, ArrayGet/Set, NewObject, MemberGet/Set, VCall, ICall (static), Cast

- [ ] MIR builder API
  - [ ] Builder to create funcs/blocks/ops safely
  - [ ] Symbol table for locals/temps mapping to ValueID

- [ ] MIR verifier
  - [ ] CFG well-formed (every block has terminator, no dead fallthrough)
  - [ ] Dominance / PHI placement asserts (basic)
  - [ ] Type checks (op arg/ret types match)

- [ ] Lowering from AST â†’ MIR
  - [ ] Expressions (constants, unary/binary ops, calls)
  - [ ] Statements (assignments, if, while, for, return, try/finally placeholder)
  - [ ] Declarations (vars, functions, classes) â†’ create globals/functions
  - [ ] Desugaring: for..in, properties, with (disallow/transform), short-circuit ops to blocks

- [ ] Golden tests for MIR
  - [ ] Emit human-readable MIR dump
  - [ ] Check in .mir snapshots for small programs

Exit criteria: MIR spec & verifier in place; ~10 small programs lower to valid MIR.

---

## Phase 2 â€” JS backend MVP (straightforward, readable JS)

- [ ] Emitter skeleton (codegen/js/)
  - [ ] Emitter{ b strings.Builder, indent int, opts Options }
  - [ ] Helpers: emit(), emitLine(), emitIndent(), { push, pop } indent

- [ ] Module packaging
  - [ ] Choose ES Module output (default) with optional IIFE fallback
  - [ ] Module header/footer; export public symbols

- [ ] Type mapping policy (doc + code)
  - [ ] DWScript ints/floats â†’ JS number
  - [ ] Boolean â†’ JS boolean
  - [ ] String â†’ JS string
  - [ ] Arrays â†’ JS arrays
  - [ ] Records/classes â†’ JS objects / ES class

- [ ] MIR â†’ JS lowering (ops & terms)
  - [ ] Arithmetic/comparison ops â†’ JS infix
- [ ] Phi â†’ move construction at block edges via temps
  - [ ] Br, CondBr, Return â†’ structured JS (if, while, return)
  - [ ] Calls â†’ JS calls; VCall â†’ obj.method(...)
  - [ ] Arrays/strings â†’ direct use; runtime helpers only when needed

- [ ] Functions & locals
  - [ ] Emit functions with parameter lists
  - [ ] Declare temps/locals at top (one let per name)

- [ ] Minimal runtime shim (JS)
  - [ ] rt.boundsCheck(i,len), optional
  - [ ] rt.strConcat(a,b) only if MIR emits it

- [ ] End-to-end tests
  - [ ] Run generated JS via Node in tests (optional)
  - [ ] Golden JS snapshots for small programs

Exit criteria: Can compile a subset (arith/control-flow/functions) to runnable, readable JS.

---

## Phase 3 â€” JS backend feature completeness

- [ ] Classes & OOP
  - [ ] ES class emission (fields in constructor; methods on prototype)
  - [ ] Inheritance mapping; super calls
  - [ ] Interfaces â†’ structural check or metadata-assisted dispatch
- [ ] Records & enums & sets
  - [ ] Records as plain objects; copy/assign semantics
  - [ ] Enums â†’ JS const objects; values as ints
  - [ ] Sets â†’ bitmasks (number) with helper ops
  - [ ] Exceptions
- [ ] Throw maps to throw
  - [ ] try/catch/finally emission
- [ ] Properties/indexers
  - [ ] Map to ES getters/setters or explicit methods (choose one)
- [ ] Generics
  - [ ] Monomorphize in frontend (Phase 1) â†’ backend sees concrete types
- [ ] Globals & init sections
  - [ ] Emit module-level init code; order handling for units
- [ ] Debuggability
  - [ ] Source maps (optional later)
  - [ ] Stable naming/mangling strategy

Exit criteria: Parity with DWScript surface (minus low-level specifics); real-world samples pass.

---

## Phase 4 â€” Stabilize Runtime ABI (shared for JS and LLVM)

- [ ] Define runtime surface (doc + headers)
  - [ ] Arrays: new, len, cap, grow, boundsCheck
  - [ ] Strings: len, concat, substr, cmp
  - [ ] Memory: (LLVM-side) dws_alloc, dws_free (or GC)
  - [ ] RTTI: type ids, is, as
  - [ ] Exceptions: throw/catch hooks (placeholder for LLVM)

- [ ] JS impl of runtime
  - [ ] Implement only the helpers used by MIR; keep minimal

- [ ] C header for LLVM runtime
  - [ ] runtime/dws_runtime.h with function prototypes
  - [ ] Note: UTF-8 string layout {i32 len, i8* data} (decide & document)

- [ ] Conformance tests
  - [ ] Same MIR program executed in JS using only runtime calls

Exit criteria: Runtime APIs frozen; both backends target the same conceptual ops.

---

## Phase 5 â€” LLVM backend groundwork (no full codegen yet)

- [ ] Choose builder
  - [ ] Use llir/llvm for pure-Go IR emission (initially)

- [ ] Module & types
  - [ ] Map DWScript types â†’ LLVM types (doc + code)
  - [ ] Struct layouts for records/classes; vtable layout

- [ ] Straight-line lowering
  - [ ] Arithmetic/comparisons â†’ LLVM ops
  - [ ] Calls to runtime (strings/arrays)

- [ ] Control flow
  - [ ] Blocks/terminators â†’ br, condbr, ret
  - [ ] PHI construction from MIR Phi

- [ ] Link test
  - [ ] Emit .ll for tiny programs; opt -S roundtrip in CI (if available)
  - [ ] (Optional) Compile via llc to object; link with stub runtime

Exit criteria: Tiny MIR functions become valid LLVM IR modules that link.

---

## Phase 6 â€” Testing & tooling hardening

- [ ] Golden tests
  - [ ] MIR dumps
  - [ ] JS output snapshots
  - [ ] LLVM IR snapshots

- [ ] Execution tests
  - [ ] Run JS outputs with Node and compare stdout/return values
  - [ ] (Optional later) Run LLVM outputs with lli when runtime exists

- [ ] Fuzzing
  - [ ] Fuzz frontend (parser/typer)
  - [ ] Fuzz MIR builder/verifier

- [ ] Coverage & perf checks
  - [ ] Benchmarks for codegen latency
  - [ ] Micro-benchmarks for runtime helpers

---

## Phase 7 â€” Language edge cases & completeness

- [ ] Short-circuiting & evaluation order (strictly match DWScript)
- [ ] Constant folding & literal handling
- [ ] Operator overloading / method resolution nuances
- [ ] Unit/import cycles & init ordering
- [ ] Numeric corner cases (overflow semanticsâ€”document & test)
- [ ] Unicode strings (encoding; JS vs LLVM consistency)

---

## Phase 8 â€” Developer experience & docs

- [ ] CLI UX
  - [ ] go-dws build --target=js --out=...
  - [ ] go-dws dump --stage=mir

- [ ] Docs
  - [ ] MIR spec (with examples)
  - [ ] Backend interface guide (how to add a new target)
  - [ ] Runtime ABI reference (C header + JS equivalents)
  - [ ] "How to read generated JS" guide

- [ ] Examples
  - [ ] examples/ with small DWScript programs and generated JS

---

## Phase 9 â€” Performance & polish

- [ ] JS emission quality
  - [ ] Dead-temp elimination in emitter (simple liveness)
  - [ ] Compact phi lowering where possible
  - [ ] Optional: JS minify switch

- [ ] Pretty vs compact modes
  - [ ] MIR optimizations (safe & small)

- [ ] Const-prop, copy-prop, trivial DCE (block-local)
  - [ ] Branch folding (if (true), if (false))

- [ ] LLVM prep
  - [ ] Ensure MIR is SSA-friendly (fewer Allocas)
  - [ ] Mark runtime calls with attributes (nounwind, readonly) in lowering (when LLVM backend grows)

---

## Backlog (nice-to-haves / later)

- [ ] Source maps (DWScript â†’ JS)
- [ ] Interactive playground for DWScriptâ†’JS
- [ ] Real LLVM EH (invoke/landingpad) after no-EH mode stabilizes
- [ ] GC strategy evaluation (Boehm vs ARC vs Wasm GC if targeting Wasm)
- [ ] ES module dependency graph & tree-shaking hints

## Issue/PR Checklist Templates

### MIR Feature PR Template

- [ ] Types updated in `mir` package
- [ ] `Builder` & `Verifier` updated
- [ ] Lowering from AST added
- [ ] MIR dump golden tests updated/added
- [ ] Docs: MIR spec snippet

### JS Backend Feature PR Template

- [ ] New op(s) lowered in `codegen/js`
- [ ] `Emitter` unit tests
- [ ] Golden JS snapshots
- [ ] Example added/updated
- [ ] Runtime helper added (if any) + tests

### Runtime Change PR Template

- [ ] ABI change documented in `runtime` package
- [ ] JS runtime updated
- [ ] C header updated
- [ ] Conformance tests pass on both backends (where applicable)

## Concrete first 10 tasks to open as issues

1. [ ] Create `mir/` package skeleton with `Func`/`Block`/`Op`/`Term` types and MIR dump.
2. [ ] Implement MIR verifier (basic invariants).
3. [ ] ASTâ†’MIR lowering for expressions (literals, arithmetic, calls).
4. [ ] ASTâ†’MIR lowering for control flow (if, while, return).
5. [ ] JS emitter scaffolding in `codegen/js/` with pretty-print support.
6. [ ] Lower arithmetic & return to JS; golden snapshot tests.
7. [ ] Implement locals/temps declaration policy in JS emitter.
8. [ ] Add arrays (MIR ops + JS lowering) with optional bounds helper.
9. [ ] Add classes: MIR representation + basic ES class emission.
10. [ ] Define and document runtime ABI v0; implement minimal JS runtime.
