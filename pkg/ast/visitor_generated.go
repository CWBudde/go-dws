// Code generated by cmd/gen-visitor/main.go. DO NOT EDIT.

package ast

// Walk traverses an AST in depth-first order, starting at the given node.
// It calls v.Visit(node) for each node encountered. If v.Visit returns nil,
// traversal of that node's children is skipped. Otherwise, Walk is called
// recursively for each child with the visitor returned by Visit.
//
// This function is automatically generated from AST node definitions.
// To regenerate, run: go generate ./pkg/ast
func Walk(v Visitor, node Node) {
	if v = v.Visit(node); v == nil {
		return
	}

	// Walk children based on node type
	switch n := node.(type) {
	case *ArrayDecl:
		walkArrayDecl(n, v)
	case *ArrayLiteralExpression:
		walkArrayLiteralExpression(n, v)
	case *AsExpression:
		walkAsExpression(n, v)
	case *AssignmentStatement:
		walkAssignmentStatement(n, v)
	case *BinaryExpression:
		walkBinaryExpression(n, v)
	case *BlockStatement:
		walkBlockStatement(n, v)
	case *BooleanLiteral:
		walkBooleanLiteral(n, v)
	case *BreakStatement:
		walkBreakStatement(n, v)
	case *CallExpression:
		walkCallExpression(n, v)
	case *CaseBranch:
		walkCaseBranch(n, v)
	case *CaseStatement:
		walkCaseStatement(n, v)
	case *CharLiteral:
		walkCharLiteral(n, v)
	case *ClassDecl:
		walkClassDecl(n, v)
	case *Condition:
		walkCondition(n, v)
	case *ConstDecl:
		walkConstDecl(n, v)
	case *ContinueStatement:
		walkContinueStatement(n, v)
	case *EnumDecl:
		walkEnumDecl(n, v)
	case *ExceptClause:
		walkExceptClause(n, v)
	case *ExceptionHandler:
		walkExceptionHandler(n, v)
	case *ExitStatement:
		walkExitStatement(n, v)
	case *ExpressionStatement:
		walkExpressionStatement(n, v)
	case *FieldDecl:
		walkFieldDecl(n, v)
	case *FieldInitializer:
		walkFieldInitializer(n, v)
	case *FinallyClause:
		walkFinallyClause(n, v)
	case *FloatLiteral:
		walkFloatLiteral(n, v)
	case *ForInStatement:
		walkForInStatement(n, v)
	case *ForStatement:
		walkForStatement(n, v)
	case *FunctionDecl:
		walkFunctionDecl(n, v)
	case *GroupedExpression:
		walkGroupedExpression(n, v)
	case *HelperDecl:
		walkHelperDecl(n, v)
	case *Identifier:
		walkIdentifier(n, v)
	case *IfExpression:
		walkIfExpression(n, v)
	case *IfStatement:
		walkIfStatement(n, v)
	case *ImplementsExpression:
		walkImplementsExpression(n, v)
	case *IndexExpression:
		walkIndexExpression(n, v)
	case *IntegerLiteral:
		walkIntegerLiteral(n, v)
	case *InterfaceDecl:
		walkInterfaceDecl(n, v)
	case *InterfaceMethodDecl:
		walkInterfaceMethodDecl(n, v)
	case *IsExpression:
		walkIsExpression(n, v)
	case *NewArrayExpression:
		walkNewArrayExpression(n, v)
	case *NilLiteral:
		walkNilLiteral(n, v)
	case *OldExpression:
		walkOldExpression(n, v)
	case *OperatorDecl:
		walkOperatorDecl(n, v)
	case *PostConditions:
		walkPostConditions(n, v)
	case *PreConditions:
		walkPreConditions(n, v)
	case *Program:
		walkProgram(n, v)
	case *PropertyDecl:
		walkPropertyDecl(n, v)
	case *RaiseStatement:
		walkRaiseStatement(n, v)
	case *RangeExpression:
		walkRangeExpression(n, v)
	case *RecordDecl:
		walkRecordDecl(n, v)
	case *RecordLiteralExpression:
		walkRecordLiteralExpression(n, v)
	case *RecordPropertyDecl:
		walkRecordPropertyDecl(n, v)
	case *RepeatStatement:
		walkRepeatStatement(n, v)
	case *ReturnStatement:
		walkReturnStatement(n, v)
	case *SetDecl:
		walkSetDecl(n, v)
	case *StringLiteral:
		walkStringLiteral(n, v)
	case *TryStatement:
		walkTryStatement(n, v)
	case *TypeAnnotation:
		walkTypeAnnotation(n, v)
	case *TypeDeclaration:
		walkTypeDeclaration(n, v)
	case *UnaryExpression:
		walkUnaryExpression(n, v)
	case *UnitDeclaration:
		walkUnitDeclaration(n, v)
	case *UsesClause:
		walkUsesClause(n, v)
	case *VarDeclStatement:
		walkVarDeclStatement(n, v)
	case *WhileStatement:
		walkWhileStatement(n, v)
	}
}

// walkArrayDecl walks a ArrayDecl node
func walkArrayDecl(n *ArrayDecl, v Visitor) {
	// No children to walk
}

// walkArrayLiteralExpression walks a ArrayLiteralExpression node
func walkArrayLiteralExpression(n *ArrayLiteralExpression, v Visitor) {
	for _, item := range n.Elements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkAsExpression walks a AsExpression node
func walkAsExpression(n *AsExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
}

// walkAssignmentStatement walks a AssignmentStatement node
func walkAssignmentStatement(n *AssignmentStatement, v Visitor) {
	if n.Target != nil {
		Walk(v, n.Target)
	}
	if n.Value != nil {
		Walk(v, n.Value)
	}
}

// walkBinaryExpression walks a BinaryExpression node
func walkBinaryExpression(n *BinaryExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.Right != nil {
		Walk(v, n.Right)
	}
}

// walkBlockStatement walks a BlockStatement node
func walkBlockStatement(n *BlockStatement, v Visitor) {
	for _, item := range n.Statements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkBooleanLiteral walks a BooleanLiteral node
func walkBooleanLiteral(n *BooleanLiteral, v Visitor) {
	// No children to walk
}

// walkBreakStatement walks a BreakStatement node
func walkBreakStatement(n *BreakStatement, v Visitor) {
	// No children to walk
}

// walkCallExpression walks a CallExpression node
func walkCallExpression(n *CallExpression, v Visitor) {
	if n.Function != nil {
		Walk(v, n.Function)
	}
	for _, item := range n.Arguments {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkCaseBranch walks a CaseBranch node
func walkCaseBranch(n *CaseBranch, v Visitor) {
	if n.Statement != nil {
		Walk(v, n.Statement)
	}
	for _, item := range n.Values {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkCaseStatement walks a CaseStatement node
func walkCaseStatement(n *CaseStatement, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
	if n.Else != nil {
		Walk(v, n.Else)
	}
	for _, item := range n.Cases {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkCharLiteral walks a CharLiteral node
func walkCharLiteral(n *CharLiteral, v Visitor) {
	// No children to walk
}

// walkClassDecl walks a ClassDecl node
func walkClassDecl(n *ClassDecl, v Visitor) {
	if n.Constructor != nil {
		Walk(v, n.Constructor)
	}
	if n.Destructor != nil {
		Walk(v, n.Destructor)
	}
	for _, item := range n.Operators {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Properties {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Fields {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Constants {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkCondition walks a Condition node
func walkCondition(n *Condition, v Visitor) {
	if n.Test != nil {
		Walk(v, n.Test)
	}
	if n.Message != nil {
		Walk(v, n.Message)
	}
}

// walkConstDecl walks a ConstDecl node
func walkConstDecl(n *ConstDecl, v Visitor) {
	if n.Value != nil {
		Walk(v, n.Value)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkContinueStatement walks a ContinueStatement node
func walkContinueStatement(n *ContinueStatement, v Visitor) {
	// No children to walk
}

// walkEnumDecl walks a EnumDecl node
func walkEnumDecl(n *EnumDecl, v Visitor) {
	// No children to walk
}

// walkExceptClause walks a ExceptClause node
func walkExceptClause(n *ExceptClause, v Visitor) {
	if n.ElseBlock != nil {
		Walk(v, n.ElseBlock)
	}
	for _, item := range n.Handlers {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkExceptionHandler walks a ExceptionHandler node
func walkExceptionHandler(n *ExceptionHandler, v Visitor) {
	if n.Statement != nil {
		Walk(v, n.Statement)
	}
	if n.ExceptionType != nil {
		Walk(v, n.ExceptionType)
	}
}

// walkExitStatement walks a ExitStatement node
func walkExitStatement(n *ExitStatement, v Visitor) {
	if n.ReturnValue != nil {
		Walk(v, n.ReturnValue)
	}
}

// walkExpressionStatement walks a ExpressionStatement node
func walkExpressionStatement(n *ExpressionStatement, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
}

// walkFieldDecl walks a FieldDecl node
func walkFieldDecl(n *FieldDecl, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
	if n.InitValue != nil {
		Walk(v, n.InitValue)
	}
}

// walkFieldInitializer walks a FieldInitializer node
func walkFieldInitializer(n *FieldInitializer, v Visitor) {
	if n.Value != nil {
		Walk(v, n.Value)
	}
}

// walkFinallyClause walks a FinallyClause node
func walkFinallyClause(n *FinallyClause, v Visitor) {
	if n.Block != nil {
		Walk(v, n.Block)
	}
}

// walkFloatLiteral walks a FloatLiteral node
func walkFloatLiteral(n *FloatLiteral, v Visitor) {
	// No children to walk
}

// walkForInStatement walks a ForInStatement node
func walkForInStatement(n *ForInStatement, v Visitor) {
	if n.Collection != nil {
		Walk(v, n.Collection)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
}

// walkForStatement walks a ForStatement node
func walkForStatement(n *ForStatement, v Visitor) {
	if n.Start != nil {
		Walk(v, n.Start)
	}
	if n.EndValue != nil {
		Walk(v, n.EndValue)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.Step != nil {
		Walk(v, n.Step)
	}
}

// walkFunctionDecl walks a FunctionDecl node
func walkFunctionDecl(n *FunctionDecl, v Visitor) {
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.PreConditions != nil {
		Walk(v, n.PreConditions)
	}
	if n.PostConditions != nil {
		Walk(v, n.PostConditions)
	}
	for _, item := range n.Parameters {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkGroupedExpression walks a GroupedExpression node
func walkGroupedExpression(n *GroupedExpression, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
}

// walkHelperDecl walks a HelperDecl node
func walkHelperDecl(n *HelperDecl, v Visitor) {
	if n.ForType != nil {
		Walk(v, n.ForType)
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Properties {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.ClassVars {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.ClassConsts {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.PrivateMembers {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.PublicMembers {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkIdentifier walks a Identifier node
func walkIdentifier(n *Identifier, v Visitor) {
	// No children to walk
}

// walkIfExpression walks a IfExpression node
func walkIfExpression(n *IfExpression, v Visitor) {
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
	if n.Consequence != nil {
		Walk(v, n.Consequence)
	}
	if n.Alternative != nil {
		Walk(v, n.Alternative)
	}
}

// walkIfStatement walks a IfStatement node
func walkIfStatement(n *IfStatement, v Visitor) {
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
	if n.Consequence != nil {
		Walk(v, n.Consequence)
	}
	if n.Alternative != nil {
		Walk(v, n.Alternative)
	}
}

// walkImplementsExpression walks a ImplementsExpression node
func walkImplementsExpression(n *ImplementsExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
}

// walkIndexExpression walks a IndexExpression node
func walkIndexExpression(n *IndexExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.Index != nil {
		Walk(v, n.Index)
	}
}

// walkIntegerLiteral walks a IntegerLiteral node
func walkIntegerLiteral(n *IntegerLiteral, v Visitor) {
	// No children to walk
}

// walkInterfaceDecl walks a InterfaceDecl node
func walkInterfaceDecl(n *InterfaceDecl, v Visitor) {
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkInterfaceMethodDecl walks a InterfaceMethodDecl node
func walkInterfaceMethodDecl(n *InterfaceMethodDecl, v Visitor) {
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	for _, item := range n.Parameters {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkIsExpression walks a IsExpression node
func walkIsExpression(n *IsExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
	if n.Right != nil {
		Walk(v, n.Right)
	}
}

// walkNewArrayExpression walks a NewArrayExpression node
func walkNewArrayExpression(n *NewArrayExpression, v Visitor) {
	for _, item := range n.Dimensions {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkNilLiteral walks a NilLiteral node
func walkNilLiteral(n *NilLiteral, v Visitor) {
	// No children to walk
}

// walkOldExpression walks a OldExpression node
func walkOldExpression(n *OldExpression, v Visitor) {
	// No children to walk
}

// walkOperatorDecl walks a OperatorDecl node
func walkOperatorDecl(n *OperatorDecl, v Visitor) {
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	for _, item := range n.OperandTypes {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkPostConditions walks a PostConditions node
func walkPostConditions(n *PostConditions, v Visitor) {
	for _, item := range n.Conditions {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkPreConditions walks a PreConditions node
func walkPreConditions(n *PreConditions, v Visitor) {
	for _, item := range n.Conditions {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkProgram walks a Program node
func walkProgram(n *Program, v Visitor) {
	for _, item := range n.Statements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkPropertyDecl walks a PropertyDecl node
func walkPropertyDecl(n *PropertyDecl, v Visitor) {
	if n.ReadSpec != nil {
		Walk(v, n.ReadSpec)
	}
	if n.WriteSpec != nil {
		Walk(v, n.WriteSpec)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
	for _, item := range n.IndexParams {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkRaiseStatement walks a RaiseStatement node
func walkRaiseStatement(n *RaiseStatement, v Visitor) {
	if n.Exception != nil {
		Walk(v, n.Exception)
	}
}

// walkRangeExpression walks a RangeExpression node
func walkRangeExpression(n *RangeExpression, v Visitor) {
	if n.Start != nil {
		Walk(v, n.Start)
	}
	if n.RangeEnd != nil {
		Walk(v, n.RangeEnd)
	}
}

// walkRecordDecl walks a RecordDecl node
func walkRecordDecl(n *RecordDecl, v Visitor) {
	for _, item := range n.Fields {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
	for i := range n.Properties {
		Walk(v, &n.Properties[i])
	}
}

// walkRecordLiteralExpression walks a RecordLiteralExpression node
func walkRecordLiteralExpression(n *RecordLiteralExpression, v Visitor) {
	// No children to walk
}

// walkRecordPropertyDecl walks a RecordPropertyDecl node
func walkRecordPropertyDecl(n *RecordPropertyDecl, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkRepeatStatement walks a RepeatStatement node
func walkRepeatStatement(n *RepeatStatement, v Visitor) {
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
}

// walkReturnStatement walks a ReturnStatement node
func walkReturnStatement(n *ReturnStatement, v Visitor) {
	if n.ReturnValue != nil {
		Walk(v, n.ReturnValue)
	}
}

// walkSetDecl walks a SetDecl node
func walkSetDecl(n *SetDecl, v Visitor) {
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// walkStringLiteral walks a StringLiteral node
func walkStringLiteral(n *StringLiteral, v Visitor) {
	// No children to walk
}

// walkTryStatement walks a TryStatement node
func walkTryStatement(n *TryStatement, v Visitor) {
	if n.TryBlock != nil {
		Walk(v, n.TryBlock)
	}
	if n.ExceptClause != nil {
		Walk(v, n.ExceptClause)
	}
}

// walkTypeAnnotation walks a TypeAnnotation node
func walkTypeAnnotation(n *TypeAnnotation, v Visitor) {
	if n.InlineType != nil {
		Walk(v, n.InlineType)
	}
}

// walkTypeDeclaration walks a TypeDeclaration node
func walkTypeDeclaration(n *TypeDeclaration, v Visitor) {
	if n.AliasedType != nil {
		Walk(v, n.AliasedType)
	}
}

// walkUnaryExpression walks a UnaryExpression node
func walkUnaryExpression(n *UnaryExpression, v Visitor) {
	if n.Right != nil {
		Walk(v, n.Right)
	}
}

// walkUnitDeclaration walks a UnitDeclaration node
func walkUnitDeclaration(n *UnitDeclaration, v Visitor) {
	if n.InterfaceSection != nil {
		Walk(v, n.InterfaceSection)
	}
	if n.ImplementationSection != nil {
		Walk(v, n.ImplementationSection)
	}
	if n.InitSection != nil {
		Walk(v, n.InitSection)
	}
	if n.FinalSection != nil {
		Walk(v, n.FinalSection)
	}
}

// walkUsesClause walks a UsesClause node
func walkUsesClause(n *UsesClause, v Visitor) {
	// No children to walk
}

// walkVarDeclStatement walks a VarDeclStatement node
func walkVarDeclStatement(n *VarDeclStatement, v Visitor) {
	if n.Value != nil {
		Walk(v, n.Value)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkWhileStatement walks a WhileStatement node
func walkWhileStatement(n *WhileStatement, v Visitor) {
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
}

// walkParameter walks the Node fields of a Parameter
func walkParameter(param *Parameter, v Visitor) {
	if param == nil {
		return
	}
	if param.Name != nil {
		Walk(v, param.Name)
	}
	if param.Type != nil {
		Walk(v, param.Type)
	}
	if param.DefaultValue != nil {
		Walk(v, param.DefaultValue)
	}
}
