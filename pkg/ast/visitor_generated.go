// Code generated by cmd/gen-visitor/main.go. DO NOT EDIT.

package ast

// Walk traverses an AST in depth-first order, starting at the given node.
// It calls v.Visit(node) for each node encountered. If v.Visit returns nil,
// traversal of that node's children is skipped. Otherwise, Walk is called
// recursively for each child with the visitor returned by Visit.
//
// This function is automatically generated from AST node definitions.
// To regenerate, run: go generate ./pkg/ast
func Walk(v Visitor, node Node) {
	if v = v.Visit(node); v == nil {
		return
	}

	// Walk children based on node type
	switch n := node.(type) {
	case *AddressOfExpression:
		walkAddressOfExpression(n, v)
	case *ArrayDecl:
		walkArrayDecl(n, v)
	case *ArrayLiteralExpression:
		walkArrayLiteralExpression(n, v)
	case *ArrayTypeNode:
		walkArrayTypeNode(n, v)
	case *AsExpression:
		walkAsExpression(n, v)
	case *AssignmentStatement:
		walkAssignmentStatement(n, v)
	case *BinaryExpression:
		walkBinaryExpression(n, v)
	case *BlockStatement:
		walkBlockStatement(n, v)
	case *BooleanLiteral:
		walkBooleanLiteral(n, v)
	case *BreakStatement:
		walkBreakStatement(n, v)
	case *CallExpression:
		walkCallExpression(n, v)
	case *CaseStatement:
		walkCaseStatement(n, v)
	case *CharLiteral:
		walkCharLiteral(n, v)
	case *ClassDecl:
		walkClassDecl(n, v)
	case *ClassOfTypeNode:
		walkClassOfTypeNode(n, v)
	case *Condition:
		walkCondition(n, v)
	case *ConstDecl:
		walkConstDecl(n, v)
	case *ContinueStatement:
		walkContinueStatement(n, v)
	case *EnumDecl:
		walkEnumDecl(n, v)
	case *ExitStatement:
		walkExitStatement(n, v)
	case *ExpressionStatement:
		walkExpressionStatement(n, v)
	case *FieldDecl:
		walkFieldDecl(n, v)
	case *FieldInitializer:
		walkFieldInitializer(n, v)
	case *FinallyClause:
		walkFinallyClause(n, v)
	case *FloatLiteral:
		walkFloatLiteral(n, v)
	case *ForInStatement:
		walkForInStatement(n, v)
	case *ForStatement:
		walkForStatement(n, v)
	case *FunctionDecl:
		walkFunctionDecl(n, v)
	case *FunctionPointerTypeNode:
		walkFunctionPointerTypeNode(n, v)
	case *GroupedExpression:
		walkGroupedExpression(n, v)
	case *HelperDecl:
		walkHelperDecl(n, v)
	case *Identifier:
		walkIdentifier(n, v)
	case *IfExpression:
		walkIfExpression(n, v)
	case *IfStatement:
		walkIfStatement(n, v)
	case *ImplementsExpression:
		walkImplementsExpression(n, v)
	case *IndexExpression:
		walkIndexExpression(n, v)
	case *InheritedExpression:
		walkInheritedExpression(n, v)
	case *IntegerLiteral:
		walkIntegerLiteral(n, v)
	case *InterfaceDecl:
		walkInterfaceDecl(n, v)
	case *InterfaceMethodDecl:
		walkInterfaceMethodDecl(n, v)
	case *IsExpression:
		walkIsExpression(n, v)
	case *LambdaExpression:
		walkLambdaExpression(n, v)
	case *MemberAccessExpression:
		walkMemberAccessExpression(n, v)
	case *MethodCallExpression:
		walkMethodCallExpression(n, v)
	case *NewArrayExpression:
		walkNewArrayExpression(n, v)
	case *NewExpression:
		walkNewExpression(n, v)
	case *NilLiteral:
		walkNilLiteral(n, v)
	case *OldExpression:
		walkOldExpression(n, v)
	case *OperatorDecl:
		walkOperatorDecl(n, v)
	case *PostConditions:
		walkPostConditions(n, v)
	case *PreConditions:
		walkPreConditions(n, v)
	case *Program:
		walkProgram(n, v)
	case *PropertyDecl:
		walkPropertyDecl(n, v)
	case *RaiseStatement:
		walkRaiseStatement(n, v)
	case *RangeExpression:
		walkRangeExpression(n, v)
	case *RecordDecl:
		walkRecordDecl(n, v)
	case *RecordLiteralExpression:
		walkRecordLiteralExpression(n, v)
	case *RecordPropertyDecl:
		walkRecordPropertyDecl(n, v)
	case *RepeatStatement:
		walkRepeatStatement(n, v)
	case *ReturnStatement:
		walkReturnStatement(n, v)
	case *SetDecl:
		walkSetDecl(n, v)
	case *SetLiteral:
		walkSetLiteral(n, v)
	case *SetTypeNode:
		walkSetTypeNode(n, v)
	case *StringLiteral:
		walkStringLiteral(n, v)
	case *TryStatement:
		walkTryStatement(n, v)
	case *TypeAnnotation:
		walkTypeAnnotation(n, v)
	case *TypeDeclaration:
		walkTypeDeclaration(n, v)
	case *UnaryExpression:
		walkUnaryExpression(n, v)
	case *UnitDeclaration:
		walkUnitDeclaration(n, v)
	case *UsesClause:
		walkUsesClause(n, v)
	case *VarDeclStatement:
		walkVarDeclStatement(n, v)
	case *WhileStatement:
		walkWhileStatement(n, v)
	}
}

// walkAddressOfExpression walks a AddressOfExpression node
func walkAddressOfExpression(n *AddressOfExpression, v Visitor) {
	// No children to walk
}

// walkArrayDecl walks a ArrayDecl node
func walkArrayDecl(n *ArrayDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
}

// walkArrayLiteralExpression walks a ArrayLiteralExpression node
func walkArrayLiteralExpression(n *ArrayLiteralExpression, v Visitor) {
	for _, item := range n.Elements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkArrayTypeNode walks a ArrayTypeNode node
func walkArrayTypeNode(n *ArrayTypeNode, v Visitor) {
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
	if n.LowBound != nil {
		Walk(v, n.LowBound)
	}
	if n.HighBound != nil {
		Walk(v, n.HighBound)
	}
	if n.IndexType != nil {
		Walk(v, n.IndexType)
	}
}

// walkAsExpression walks a AsExpression node
func walkAsExpression(n *AsExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
}

// walkAssignmentStatement walks a AssignmentStatement node
func walkAssignmentStatement(n *AssignmentStatement, v Visitor) {
	if n.Target != nil {
		Walk(v, n.Target)
	}
	if n.Value != nil {
		Walk(v, n.Value)
	}
}

// walkBinaryExpression walks a BinaryExpression node
func walkBinaryExpression(n *BinaryExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.Right != nil {
		Walk(v, n.Right)
	}
}

// walkBlockStatement walks a BlockStatement node
func walkBlockStatement(n *BlockStatement, v Visitor) {
	for _, item := range n.Statements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkBooleanLiteral walks a BooleanLiteral node
func walkBooleanLiteral(n *BooleanLiteral, v Visitor) {
	// No children to walk
}

// walkBreakStatement walks a BreakStatement node
func walkBreakStatement(n *BreakStatement, v Visitor) {
	// No children to walk
}

// walkCallExpression walks a CallExpression node
func walkCallExpression(n *CallExpression, v Visitor) {
	if n.Function != nil {
		Walk(v, n.Function)
	}
	for _, item := range n.Arguments {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkCaseStatement walks a CaseStatement node
func walkCaseStatement(n *CaseStatement, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
	if n.Else != nil {
		Walk(v, n.Else)
	}
	for _, item := range n.Cases {
		if item != nil {
			walkCaseBranch(item, v)
		}
	}
}

// walkCharLiteral walks a CharLiteral node
func walkCharLiteral(n *CharLiteral, v Visitor) {
	// No children to walk
}

// walkClassDecl walks a ClassDecl node
func walkClassDecl(n *ClassDecl, v Visitor) {
	if n.Constructor != nil {
		Walk(v, n.Constructor)
	}
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Parent != nil {
		Walk(v, n.Parent)
	}
	if n.Destructor != nil {
		Walk(v, n.Destructor)
	}
	for _, item := range n.Interfaces {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Operators {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Properties {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Fields {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Constants {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkClassOfTypeNode walks a ClassOfTypeNode node
func walkClassOfTypeNode(n *ClassOfTypeNode, v Visitor) {
	if n.ClassType != nil {
		Walk(v, n.ClassType)
	}
}

// walkCondition walks a Condition node
func walkCondition(n *Condition, v Visitor) {
	if n.Test != nil {
		Walk(v, n.Test)
	}
	if n.Message != nil {
		Walk(v, n.Message)
	}
}

// walkConstDecl walks a ConstDecl node
func walkConstDecl(n *ConstDecl, v Visitor) {
	if n.Value != nil {
		Walk(v, n.Value)
	}
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkContinueStatement walks a ContinueStatement node
func walkContinueStatement(n *ContinueStatement, v Visitor) {
	// No children to walk
}

// walkEnumDecl walks a EnumDecl node
func walkEnumDecl(n *EnumDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
}

// walkExitStatement walks a ExitStatement node
func walkExitStatement(n *ExitStatement, v Visitor) {
	if n.ReturnValue != nil {
		Walk(v, n.ReturnValue)
	}
}

// walkExpressionStatement walks a ExpressionStatement node
func walkExpressionStatement(n *ExpressionStatement, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
}

// walkFieldDecl walks a FieldDecl node
func walkFieldDecl(n *FieldDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
	if n.InitValue != nil {
		Walk(v, n.InitValue)
	}
}

// walkFieldInitializer walks a FieldInitializer node
func walkFieldInitializer(n *FieldInitializer, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Value != nil {
		Walk(v, n.Value)
	}
}

// walkFinallyClause walks a FinallyClause node
func walkFinallyClause(n *FinallyClause, v Visitor) {
	if n.Block != nil {
		Walk(v, n.Block)
	}
}

// walkFloatLiteral walks a FloatLiteral node
func walkFloatLiteral(n *FloatLiteral, v Visitor) {
	// No children to walk
}

// walkForInStatement walks a ForInStatement node
func walkForInStatement(n *ForInStatement, v Visitor) {
	if n.Variable != nil {
		Walk(v, n.Variable)
	}
	if n.Collection != nil {
		Walk(v, n.Collection)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
}

// walkForStatement walks a ForStatement node
func walkForStatement(n *ForStatement, v Visitor) {
	if n.Start != nil {
		Walk(v, n.Start)
	}
	if n.EndValue != nil {
		Walk(v, n.EndValue)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.Step != nil {
		Walk(v, n.Step)
	}
	if n.Variable != nil {
		Walk(v, n.Variable)
	}
}

// walkFunctionDecl walks a FunctionDecl node
func walkFunctionDecl(n *FunctionDecl, v Visitor) {
	if n.ClassName != nil {
		Walk(v, n.ClassName)
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.PreConditions != nil {
		Walk(v, n.PreConditions)
	}
	if n.PostConditions != nil {
		Walk(v, n.PostConditions)
	}
	if n.Name != nil {
		Walk(v, n.Name)
	}
	for _, item := range n.Parameters {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkFunctionPointerTypeNode walks a FunctionPointerTypeNode node
func walkFunctionPointerTypeNode(n *FunctionPointerTypeNode, v Visitor) {
	for _, item := range n.Parameters {
		if item != nil {
			walkParameter(item, v)
		}
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
}

// walkGroupedExpression walks a GroupedExpression node
func walkGroupedExpression(n *GroupedExpression, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
}

// walkHelperDecl walks a HelperDecl node
func walkHelperDecl(n *HelperDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.ParentHelper != nil {
		Walk(v, n.ParentHelper)
	}
	if n.ForType != nil {
		Walk(v, n.ForType)
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Properties {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.ClassVars {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.ClassConsts {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.PrivateMembers {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.PublicMembers {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkIdentifier walks a Identifier node
func walkIdentifier(n *Identifier, v Visitor) {
	// No children to walk
}

// walkIfExpression walks a IfExpression node
func walkIfExpression(n *IfExpression, v Visitor) {
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
	if n.Consequence != nil {
		Walk(v, n.Consequence)
	}
	if n.Alternative != nil {
		Walk(v, n.Alternative)
	}
}

// walkIfStatement walks a IfStatement node
func walkIfStatement(n *IfStatement, v Visitor) {
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
	if n.Consequence != nil {
		Walk(v, n.Consequence)
	}
	if n.Alternative != nil {
		Walk(v, n.Alternative)
	}
}

// walkImplementsExpression walks a ImplementsExpression node
func walkImplementsExpression(n *ImplementsExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
}

// walkIndexExpression walks a IndexExpression node
func walkIndexExpression(n *IndexExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.Index != nil {
		Walk(v, n.Index)
	}
}

// walkInheritedExpression walks a InheritedExpression node
func walkInheritedExpression(n *InheritedExpression, v Visitor) {
	if n.Method != nil {
		Walk(v, n.Method)
	}
	for _, item := range n.Arguments {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkIntegerLiteral walks a IntegerLiteral node
func walkIntegerLiteral(n *IntegerLiteral, v Visitor) {
	// No children to walk
}

// walkInterfaceDecl walks a InterfaceDecl node
func walkInterfaceDecl(n *InterfaceDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Parent != nil {
		Walk(v, n.Parent)
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkInterfaceMethodDecl walks a InterfaceMethodDecl node
func walkInterfaceMethodDecl(n *InterfaceMethodDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	for _, item := range n.Parameters {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkIsExpression walks a IsExpression node
func walkIsExpression(n *IsExpression, v Visitor) {
	if n.Left != nil {
		Walk(v, n.Left)
	}
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
	if n.Right != nil {
		Walk(v, n.Right)
	}
}

// walkLambdaExpression walks a LambdaExpression node
func walkLambdaExpression(n *LambdaExpression, v Visitor) {
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	for _, item := range n.Parameters {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkMemberAccessExpression walks a MemberAccessExpression node
func walkMemberAccessExpression(n *MemberAccessExpression, v Visitor) {
	if n.Object != nil {
		Walk(v, n.Object)
	}
	if n.Member != nil {
		Walk(v, n.Member)
	}
}

// walkMethodCallExpression walks a MethodCallExpression node
func walkMethodCallExpression(n *MethodCallExpression, v Visitor) {
	if n.Object != nil {
		Walk(v, n.Object)
	}
	if n.Method != nil {
		Walk(v, n.Method)
	}
	for _, item := range n.Arguments {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkNewArrayExpression walks a NewArrayExpression node
func walkNewArrayExpression(n *NewArrayExpression, v Visitor) {
	if n.ElementTypeName != nil {
		Walk(v, n.ElementTypeName)
	}
	for _, item := range n.Dimensions {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkNewExpression walks a NewExpression node
func walkNewExpression(n *NewExpression, v Visitor) {
	if n.ClassName != nil {
		Walk(v, n.ClassName)
	}
	for _, item := range n.Arguments {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkNilLiteral walks a NilLiteral node
func walkNilLiteral(n *NilLiteral, v Visitor) {
	// No children to walk
}

// walkOldExpression walks a OldExpression node
func walkOldExpression(n *OldExpression, v Visitor) {
	if n.Identifier != nil {
		Walk(v, n.Identifier)
	}
}

// walkOperatorDecl walks a OperatorDecl node
func walkOperatorDecl(n *OperatorDecl, v Visitor) {
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	if n.Binding != nil {
		Walk(v, n.Binding)
	}
	for _, item := range n.OperandTypes {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkPostConditions walks a PostConditions node
func walkPostConditions(n *PostConditions, v Visitor) {
	for _, item := range n.Conditions {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkPreConditions walks a PreConditions node
func walkPreConditions(n *PreConditions, v Visitor) {
	for _, item := range n.Conditions {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkProgram walks a Program node
func walkProgram(n *Program, v Visitor) {
	for _, item := range n.Statements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkPropertyDecl walks a PropertyDecl node
func walkPropertyDecl(n *PropertyDecl, v Visitor) {
	if n.ReadSpec != nil {
		Walk(v, n.ReadSpec)
	}
	if n.WriteSpec != nil {
		Walk(v, n.WriteSpec)
	}
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
	for _, item := range n.IndexParams {
		if item != nil {
			walkParameter(item, v)
		}
	}
}

// walkRaiseStatement walks a RaiseStatement node
func walkRaiseStatement(n *RaiseStatement, v Visitor) {
	if n.Exception != nil {
		Walk(v, n.Exception)
	}
}

// walkRangeExpression walks a RangeExpression node
func walkRangeExpression(n *RangeExpression, v Visitor) {
	if n.Start != nil {
		Walk(v, n.Start)
	}
	if n.RangeEnd != nil {
		Walk(v, n.RangeEnd)
	}
}

// walkRecordDecl walks a RecordDecl node
func walkRecordDecl(n *RecordDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	for _, item := range n.Fields {
		if item != nil {
			Walk(v, item)
		}
	}
	for _, item := range n.Methods {
		if item != nil {
			Walk(v, item)
		}
	}
	for i := range n.Properties {
		Walk(v, &n.Properties[i])
	}
}

// walkRecordLiteralExpression walks a RecordLiteralExpression node
func walkRecordLiteralExpression(n *RecordLiteralExpression, v Visitor) {
	if n.TypeName != nil {
		Walk(v, n.TypeName)
	}
}

// walkRecordPropertyDecl walks a RecordPropertyDecl node
func walkRecordPropertyDecl(n *RecordPropertyDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkRepeatStatement walks a RepeatStatement node
func walkRepeatStatement(n *RepeatStatement, v Visitor) {
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
}

// walkReturnStatement walks a ReturnStatement node
func walkReturnStatement(n *ReturnStatement, v Visitor) {
	if n.ReturnValue != nil {
		Walk(v, n.ReturnValue)
	}
}

// walkSetDecl walks a SetDecl node
func walkSetDecl(n *SetDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// walkSetLiteral walks a SetLiteral node
func walkSetLiteral(n *SetLiteral, v Visitor) {
	for _, item := range n.Elements {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkSetTypeNode walks a SetTypeNode node
func walkSetTypeNode(n *SetTypeNode, v Visitor) {
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// walkStringLiteral walks a StringLiteral node
func walkStringLiteral(n *StringLiteral, v Visitor) {
	// No children to walk
}

// walkTryStatement walks a TryStatement node
func walkTryStatement(n *TryStatement, v Visitor) {
	if n.TryBlock != nil {
		Walk(v, n.TryBlock)
	}
	walkExceptClause(n.ExceptClause, v)
	if n.FinallyClause != nil {
		Walk(v, n.FinallyClause)
	}
}

// walkTypeAnnotation walks a TypeAnnotation node
func walkTypeAnnotation(n *TypeAnnotation, v Visitor) {
	if n.InlineType != nil {
		Walk(v, n.InlineType)
	}
}

// walkTypeDeclaration walks a TypeDeclaration node
func walkTypeDeclaration(n *TypeDeclaration, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.AliasedType != nil {
		Walk(v, n.AliasedType)
	}
	if n.LowBound != nil {
		Walk(v, n.LowBound)
	}
	if n.HighBound != nil {
		Walk(v, n.HighBound)
	}
	if n.FunctionPointerType != nil {
		Walk(v, n.FunctionPointerType)
	}
}

// walkUnaryExpression walks a UnaryExpression node
func walkUnaryExpression(n *UnaryExpression, v Visitor) {
	if n.Right != nil {
		Walk(v, n.Right)
	}
}

// walkUnitDeclaration walks a UnitDeclaration node
func walkUnitDeclaration(n *UnitDeclaration, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.InterfaceSection != nil {
		Walk(v, n.InterfaceSection)
	}
	if n.ImplementationSection != nil {
		Walk(v, n.ImplementationSection)
	}
	if n.InitSection != nil {
		Walk(v, n.InitSection)
	}
	if n.FinalSection != nil {
		Walk(v, n.FinalSection)
	}
}

// walkUsesClause walks a UsesClause node
func walkUsesClause(n *UsesClause, v Visitor) {
	for _, item := range n.Units {
		if item != nil {
			Walk(v, item)
		}
	}
}

// walkVarDeclStatement walks a VarDeclStatement node
func walkVarDeclStatement(n *VarDeclStatement, v Visitor) {
	if n.Value != nil {
		Walk(v, n.Value)
	}
	for _, item := range n.Names {
		if item != nil {
			Walk(v, item)
		}
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkWhileStatement walks a WhileStatement node
func walkWhileStatement(n *WhileStatement, v Visitor) {
	if n.Condition != nil {
		Walk(v, n.Condition)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
}

// walkParameter walks the Node fields of a Parameter
func walkParameter(param *Parameter, v Visitor) {
	if param == nil {
		return
	}
	if param.Name != nil {
		Walk(v, param.Name)
	}
	if param.Type != nil {
		Walk(v, param.Type)
	}
	if param.DefaultValue != nil {
		Walk(v, param.DefaultValue)
	}
}

// walkCaseBranch walks the Node fields of a CaseBranch
func walkCaseBranch(branch *CaseBranch, v Visitor) {
	if branch == nil {
		return
	}
	if branch.Statement != nil {
		Walk(v, branch.Statement)
	}
	for _, val := range branch.Values {
		if val != nil {
			Walk(v, val)
		}
	}
}

// walkExceptClause walks the Node fields of an ExceptClause
func walkExceptClause(clause *ExceptClause, v Visitor) {
	if clause == nil {
		return
	}
	if clause.ElseBlock != nil {
		Walk(v, clause.ElseBlock)
	}
	for _, handler := range clause.Handlers {
		if handler != nil {
			walkExceptionHandler(handler, v)
		}
	}
}

// walkExceptionHandler walks the Node fields of an ExceptionHandler
func walkExceptionHandler(handler *ExceptionHandler, v Visitor) {
	if handler == nil {
		return
	}
	if handler.Statement != nil {
		Walk(v, handler.Statement)
	}
	if handler.Variable != nil {
		Walk(v, handler.Variable)
	}
	if handler.ExceptionType != nil {
		Walk(v, handler.ExceptionType)
	}
}
