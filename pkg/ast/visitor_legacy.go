//go:build legacy
// +build legacy

// LEGACY CODE: This file contains the original manual visitor implementation
// and is kept for reference and comparison purposes only.
// The current implementation is in visitor_generated.go (generated by cmd/gen-visitor).
// DO NOT USE THIS CODE - it is superseded by the generated visitor.
//
// This file is excluded from normal builds via the "legacy" build tag.
// To view this code, simply read the file - it will not be compiled.

package ast

// Visitor is the interface for AST traversal using the visitor pattern.
// Implementations should define a Visit method that is called for each node.
// If Visit returns nil, the node's children are not traversed.
// Otherwise, Visit is called recursively for all child nodes.
type Visitor interface {
	Visit(node Node) (w Visitor)
}

// Walk traverses an AST in depth-first order, starting at the given node.
// It calls v.Visit(node) for each node encountered. If v.Visit returns nil,
// traversal of that node's children is skipped. Otherwise, Walk is called
// recursively for each child with the visitor returned by Visit.
//
// Walk follows the standard Go AST pattern from the go/ast package.
func Walk(v Visitor, node Node) {
	if v = v.Visit(node); v == nil {
		return
	}

	// Walk children based on node type - dispatch to type-specific functions
	switch n := node.(type) {
	// Program
	case *Program:
		walkProgram(n, v)

	// Literals
	case *Identifier:
		walkIdentifier(n, v)
	case *IntegerLiteral:
		walkIntegerLiteral(n, v)
	case *FloatLiteral:
		walkFloatLiteral(n, v)
	case *StringLiteral:
		walkStringLiteral(n, v)
	case *BooleanLiteral:
		walkBooleanLiteral(n, v)
	case *CharLiteral:
		walkCharLiteral(n, v)
	case *NilLiteral:
		walkNilLiteral(n, v)

	// Expressions
	case *AsExpression:
		walkAsExpression(n, v)
	case *ImplementsExpression:
		walkImplementsExpression(n, v)
	case *BinaryExpression:
		walkBinaryExpression(n, v)
	case *UnaryExpression:
		walkUnaryExpression(n, v)
	case *GroupedExpression:
		walkGroupedExpression(n, v)
	case *RangeExpression:
		walkRangeExpression(n, v)
	case *CallExpression:
		walkCallExpression(n, v)
	case *OldExpression:
		walkOldExpression(n, v)

	// Statements
	case *ExpressionStatement:
		walkExpressionStatement(n, v)
	case *BlockStatement:
		walkBlockStatement(n, v)
	case *VarDeclStatement:
		walkVarDeclStatement(n, v)
	case *AssignmentStatement:
		walkAssignmentStatement(n, v)
	case *ConstDecl:
		walkConstDecl(n, v)

	// Control Flow
	case *IfStatement:
		walkIfStatement(n, v)
	case *IfExpression:
		walkIfExpression(n, v)
	case *WhileStatement:
		walkWhileStatement(n, v)
	case *RepeatStatement:
		walkRepeatStatement(n, v)
	case *ForStatement:
		walkForStatement(n, v)
	case *ForInStatement:
		walkForInStatement(n, v)
	case *CaseStatement:
		walkCaseStatement(n, v)
	case *BreakStatement:
		walkBreakStatement(n, v)
	case *ContinueStatement:
		walkContinueStatement(n, v)
	case *ExitStatement:
		walkExitStatement(n, v)

	// Functions
	case *FunctionDecl:
		walkFunctionDecl(n, v)
	case *ReturnStatement:
		walkReturnStatement(n, v)

	// Contracts
	case *Condition:
		walkCondition(n, v)
	case *PreConditions:
		walkPreConditions(n, v)
	case *PostConditions:
		walkPostConditions(n, v)

	// Arrays
	case *ArrayDecl:
		walkArrayDecl(n, v)
	case *ArrayTypeAnnotation:
		walkArrayTypeAnnotation(n, v)
	case *ArrayLiteralExpression:
		walkArrayLiteralExpression(n, v)
	case *IndexExpression:
		walkIndexExpression(n, v)
	case *NewArrayExpression:
		walkNewArrayExpression(n, v)

	// Classes
	case *ClassDecl:
		walkClassDecl(n, v)
	case *FieldDecl:
		walkFieldDecl(n, v)
	case *NewExpression:
		walkNewExpression(n, v)
	case *MemberAccessExpression:
		walkMemberAccessExpression(n, v)
	case *MethodCallExpression:
		walkMethodCallExpression(n, v)
	case *InheritedExpression:
		walkInheritedExpression(n, v)

	// Enums
	case *EnumDecl:
		walkEnumDecl(n, v)
	case *EnumLiteral:
		walkEnumLiteral(n, v)

	// Records
	case *RecordDecl:
		walkRecordDecl(n, v)
	case *RecordLiteralExpression:
		walkRecordLiteralExpression(n, v)

	// Lambda
	case *LambdaExpression:
		walkLambdaExpression(n, v)

	// Sets
	case *SetDecl:
		walkSetDecl(n, v)
	case *SetLiteral:
		walkSetLiteral(n, v)

	// Properties
	case *PropertyDecl:
		walkPropertyDecl(n, v)

	// Operators
	case *OperatorDecl:
		walkOperatorDecl(n, v)

	// Exceptions
	case *TryStatement:
		walkTryStatement(n, v)
	case *RaiseStatement:
		walkRaiseStatement(n, v)

	// Interfaces
	case *InterfaceDecl:
		walkInterfaceDecl(n, v)

	// Units
	case *UnitDeclaration:
		walkUnitDeclaration(n, v)
	case *UsesClause:
		walkUsesClause(n, v)

	// Type Annotations and Expressions
	case *TypeAnnotation:
		walkTypeAnnotation(n, v)
	case *TypeDeclaration:
		walkTypeDeclaration(n, v)
	case *FunctionPointerTypeNode:
		walkFunctionPointerTypeNode(n, v)
	case *AddressOfExpression:
		walkAddressOfExpression(n, v)
	case *ArrayTypeNode:
		walkArrayTypeNode(n, v)
	case *SetTypeNode:
		walkSetTypeNode(n, v)
	}
}

// walkProgram walks a Program node
func walkProgram(n *Program, v Visitor) {
	for _, stmt := range n.Statements {
		Walk(v, stmt)
	}
}

// walkIdentifier walks an Identifier node
func walkIdentifier(n *Identifier, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkIntegerLiteral walks an IntegerLiteral node
func walkIntegerLiteral(n *IntegerLiteral, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkFloatLiteral walks a FloatLiteral node
func walkFloatLiteral(n *FloatLiteral, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkStringLiteral walks a StringLiteral node
func walkStringLiteral(n *StringLiteral, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkBooleanLiteral walks a BooleanLiteral node
func walkBooleanLiteral(n *BooleanLiteral, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkCharLiteral walks a CharLiteral node
func walkCharLiteral(n *CharLiteral, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkNilLiteral walks a NilLiteral node
func walkNilLiteral(n *NilLiteral, v Visitor) {
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkAsExpression walks an AsExpression node
func walkAsExpression(n *AsExpression, v Visitor) {
	Walk(v, n.Left)
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkImplementsExpression walks an ImplementsExpression node
func walkImplementsExpression(n *ImplementsExpression, v Visitor) {
	Walk(v, n.Left)
	if n.TargetType != nil {
		Walk(v, n.TargetType)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkBinaryExpression walks a BinaryExpression node
func walkBinaryExpression(n *BinaryExpression, v Visitor) {
	Walk(v, n.Left)
	Walk(v, n.Right)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkUnaryExpression walks a UnaryExpression node
func walkUnaryExpression(n *UnaryExpression, v Visitor) {
	Walk(v, n.Right)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkGroupedExpression walks a GroupedExpression node
func walkGroupedExpression(n *GroupedExpression, v Visitor) {
	Walk(v, n.Expression)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkRangeExpression walks a RangeExpression node
func walkRangeExpression(n *RangeExpression, v Visitor) {
	Walk(v, n.Start)
	Walk(v, n.RangeEnd)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkCallExpression walks a CallExpression node
func walkCallExpression(n *CallExpression, v Visitor) {
	Walk(v, n.Function)
	for _, arg := range n.Arguments {
		Walk(v, arg)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkOldExpression walks an OldExpression node
func walkOldExpression(n *OldExpression, v Visitor) {
	Walk(v, n.Identifier)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkExpressionStatement walks an ExpressionStatement node
func walkExpressionStatement(n *ExpressionStatement, v Visitor) {
	if n.Expression != nil {
		Walk(v, n.Expression)
	}
}

// walkBlockStatement walks a BlockStatement node
func walkBlockStatement(n *BlockStatement, v Visitor) {
	for _, stmt := range n.Statements {
		Walk(v, stmt)
	}
}

// walkVarDeclStatement walks a VarDeclStatement node
func walkVarDeclStatement(n *VarDeclStatement, v Visitor) {
	for _, name := range n.Names {
		Walk(v, name)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
	if n.Value != nil {
		Walk(v, n.Value)
	}
}

// walkAssignmentStatement walks an AssignmentStatement node
func walkAssignmentStatement(n *AssignmentStatement, v Visitor) {
	if n.Target != nil {
		Walk(v, n.Target)
	}
	if n.Value != nil {
		Walk(v, n.Value)
	}
}

// walkConstDecl walks a ConstDecl node
func walkConstDecl(n *ConstDecl, v Visitor) {
	Walk(v, n.Name)
	if n.Type != nil {
		Walk(v, n.Type)
	}
	Walk(v, n.Value)
}

// walkIfStatement walks an IfStatement node
func walkIfStatement(n *IfStatement, v Visitor) {
	Walk(v, n.Condition)
	Walk(v, n.Consequence)
	if n.Alternative != nil {
		Walk(v, n.Alternative)
	}
}

// walkIfExpression walks an IfExpression node
func walkIfExpression(n *IfExpression, v Visitor) {
	Walk(v, n.Condition)
	Walk(v, n.Consequence)
	if n.Alternative != nil {
		Walk(v, n.Alternative)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkWhileStatement walks a WhileStatement node
func walkWhileStatement(n *WhileStatement, v Visitor) {
	Walk(v, n.Condition)
	Walk(v, n.Body)
}

// walkRepeatStatement walks a RepeatStatement node
func walkRepeatStatement(n *RepeatStatement, v Visitor) {
	Walk(v, n.Body)
	Walk(v, n.Condition)
}

// walkForStatement walks a ForStatement node
func walkForStatement(n *ForStatement, v Visitor) {
	Walk(v, n.Variable)
	Walk(v, n.Start)
	Walk(v, n.EndValue)
	if n.Step != nil {
		Walk(v, n.Step)
	}
	Walk(v, n.Body)
}

// walkForInStatement walks a ForInStatement node
func walkForInStatement(n *ForInStatement, v Visitor) {
	Walk(v, n.Variable)
	Walk(v, n.Collection)
	Walk(v, n.Body)
}

// walkCaseStatement walks a CaseStatement node
func walkCaseStatement(n *CaseStatement, v Visitor) {
	Walk(v, n.Expression)
	for _, branch := range n.Cases {
		// Walk branch values and statement (CaseBranch is not a Node)
		for _, value := range branch.Values {
			Walk(v, value)
		}
		Walk(v, branch.Statement)
	}
	if n.Else != nil {
		Walk(v, n.Else)
	}
}

// walkBreakStatement walks a BreakStatement node
func walkBreakStatement(n *BreakStatement, v Visitor) {
	// No children
}

// walkContinueStatement walks a ContinueStatement node
func walkContinueStatement(n *ContinueStatement, v Visitor) {
	// No children
}

// walkExitStatement walks an ExitStatement node
func walkExitStatement(n *ExitStatement, v Visitor) {
	if n.ReturnValue != nil {
		Walk(v, n.ReturnValue)
	}
}

// walkFunctionDecl walks a FunctionDecl node
func walkFunctionDecl(n *FunctionDecl, v Visitor) {
	Walk(v, n.Name)
	if n.ClassName != nil {
		Walk(v, n.ClassName)
	}
	for _, param := range n.Parameters {
		walkParameter(param, v)
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	if n.PreConditions != nil {
		Walk(v, n.PreConditions)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.PostConditions != nil {
		Walk(v, n.PostConditions)
	}
}

// walkParameter walks a Parameter (helper for walking parameter fields)
func walkParameter(param *Parameter, v Visitor) {
	if param.Name != nil {
		Walk(v, param.Name)
	}
	if param.Type != nil {
		Walk(v, param.Type)
	}
	if param.DefaultValue != nil {
		Walk(v, param.DefaultValue)
	}
}

// walkReturnStatement walks a ReturnStatement node
func walkReturnStatement(n *ReturnStatement, v Visitor) {
	if n.ReturnValue != nil {
		Walk(v, n.ReturnValue)
	}
}

// walkCondition walks a Condition node
func walkCondition(n *Condition, v Visitor) {
	if n.Test != nil {
		Walk(v, n.Test)
	}
	if n.Message != nil {
		Walk(v, n.Message)
	}
}

// walkPreConditions walks a PreConditions node
func walkPreConditions(n *PreConditions, v Visitor) {
	for _, cond := range n.Conditions {
		Walk(v, cond)
	}
}

// walkPostConditions walks a PostConditions node
func walkPostConditions(n *PostConditions, v Visitor) {
	for _, cond := range n.Conditions {
		Walk(v, cond)
	}
}

// walkArrayDecl walks an ArrayDecl node
func walkArrayDecl(n *ArrayDecl, v Visitor) {
	Walk(v, n.Name)
	if n.ArrayType != nil {
		Walk(v, n.ArrayType)
	}
}

// walkArrayTypeAnnotation walks an ArrayTypeAnnotation node
func walkArrayTypeAnnotation(n *ArrayTypeAnnotation, v Visitor) {
	if n.LowBound != nil {
		Walk(v, n.LowBound)
	}
	if n.HighBound != nil {
		Walk(v, n.HighBound)
	}
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// walkArrayLiteralExpression walks an ArrayLiteralExpression node
func walkArrayLiteralExpression(n *ArrayLiteralExpression, v Visitor) {
	for _, elem := range n.Elements {
		Walk(v, elem)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkIndexExpression walks an IndexExpression node
func walkIndexExpression(n *IndexExpression, v Visitor) {
	Walk(v, n.Left)
	Walk(v, n.Index)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkNewArrayExpression walks a NewArrayExpression node
func walkNewArrayExpression(n *NewArrayExpression, v Visitor) {
	if n.ElementTypeName != nil {
		Walk(v, n.ElementTypeName)
	}
	for _, dim := range n.Dimensions {
		Walk(v, dim)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkClassDecl walks a ClassDecl node
func walkClassDecl(n *ClassDecl, v Visitor) {
	Walk(v, n.Name)
	if n.Parent != nil {
		Walk(v, n.Parent)
	}
	for _, iface := range n.Interfaces {
		Walk(v, iface)
	}
	for _, field := range n.Fields {
		Walk(v, field)
	}
	for _, method := range n.Methods {
		Walk(v, method)
	}
	for _, operator := range n.Operators {
		Walk(v, operator)
	}
	for _, prop := range n.Properties {
		Walk(v, prop)
	}
	if n.Constructor != nil {
		Walk(v, n.Constructor)
	}
	if n.Destructor != nil {
		Walk(v, n.Destructor)
	}
}

// walkFieldDecl walks a FieldDecl node
func walkFieldDecl(n *FieldDecl, v Visitor) {
	Walk(v, n.Name)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkNewExpression walks a NewExpression node
func walkNewExpression(n *NewExpression, v Visitor) {
	Walk(v, n.ClassName)
	for _, arg := range n.Arguments {
		Walk(v, arg)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkMemberAccessExpression walks a MemberAccessExpression node
func walkMemberAccessExpression(n *MemberAccessExpression, v Visitor) {
	Walk(v, n.Object)
	Walk(v, n.Member)
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkMethodCallExpression walks a MethodCallExpression node
func walkMethodCallExpression(n *MethodCallExpression, v Visitor) {
	Walk(v, n.Object)
	Walk(v, n.Method)
	for _, arg := range n.Arguments {
		Walk(v, arg)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkInheritedExpression walks an InheritedExpression node
func walkInheritedExpression(n *InheritedExpression, v Visitor) {
	if n.Method != nil {
		Walk(v, n.Method)
	}
	for _, arg := range n.Arguments {
		Walk(v, arg)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkEnumDecl walks an EnumDecl node
func walkEnumDecl(n *EnumDecl, v Visitor) {
	Walk(v, n.Name)
}

// walkEnumLiteral walks an EnumLiteral node
func walkEnumLiteral(n *EnumLiteral, v Visitor) {
	// No children to walk
}

// walkRecordDecl walks a RecordDecl node
func walkRecordDecl(n *RecordDecl, v Visitor) {
	Walk(v, n.Name)
	for _, field := range n.Fields {
		Walk(v, field)
	}
	for _, method := range n.Methods {
		Walk(v, method)
	}
}

// walkRecordLiteralExpression walks a RecordLiteralExpression node
func walkRecordLiteralExpression(n *RecordLiteralExpression, v Visitor) {
	if n.TypeName != nil {
		Walk(v, n.TypeName)
	}
	for _, field := range n.Fields {
		// Walk field initializer children (FieldInitializer is not a Node)
		if field.Name != nil {
			Walk(v, field.Name)
		}
		Walk(v, field.Value)
	}
}

// walkLambdaExpression walks a LambdaExpression node
func walkLambdaExpression(n *LambdaExpression, v Visitor) {
	for _, param := range n.Parameters {
		walkParameter(param, v)
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
	if n.Body != nil {
		Walk(v, n.Body)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkSetDecl walks a SetDecl node
func walkSetDecl(n *SetDecl, v Visitor) {
	if n.Name != nil {
		Walk(v, n.Name)
	}
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// walkSetLiteral walks a SetLiteral node
func walkSetLiteral(n *SetLiteral, v Visitor) {
	for _, elem := range n.Elements {
		Walk(v, elem)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkPropertyDecl walks a PropertyDecl node
func walkPropertyDecl(n *PropertyDecl, v Visitor) {
	Walk(v, n.Name)
	if n.Type != nil {
		Walk(v, n.Type)
	}
	for _, param := range n.IndexParams {
		walkParameter(param, v)
	}
	if n.ReadSpec != nil {
		Walk(v, n.ReadSpec)
	}
	if n.WriteSpec != nil {
		Walk(v, n.WriteSpec)
	}
}

// walkOperatorDecl walks an OperatorDecl node
func walkOperatorDecl(n *OperatorDecl, v Visitor) {
	if n.Binding != nil {
		Walk(v, n.Binding)
	}
	for _, operandType := range n.OperandTypes {
		Walk(v, operandType)
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
}

// walkTryStatement walks a TryStatement node
func walkTryStatement(n *TryStatement, v Visitor) {
	if n.TryBlock != nil {
		Walk(v, n.TryBlock)
	}
	if n.ExceptClause != nil {
		// Walk except clause children (ExceptClause is not a Node)
		for _, handler := range n.ExceptClause.Handlers {
			// Walk exception handler children (ExceptionHandler is not a Node)
			if handler.Variable != nil {
				Walk(v, handler.Variable)
			}
			if handler.ExceptionType != nil {
				Walk(v, handler.ExceptionType)
			}
			if handler.Statement != nil {
				Walk(v, handler.Statement)
			}
		}
		if n.ExceptClause.ElseBlock != nil {
			Walk(v, n.ExceptClause.ElseBlock)
		}
	}
	if n.FinallyClause != nil {
		// Walk finally clause children (FinallyClause is not a Node)
		if n.FinallyClause.Block != nil {
			Walk(v, n.FinallyClause.Block)
		}
	}
}

// walkRaiseStatement walks a RaiseStatement node
func walkRaiseStatement(n *RaiseStatement, v Visitor) {
	if n.Exception != nil {
		Walk(v, n.Exception)
	}
}

// walkInterfaceDecl walks an InterfaceDecl node
func walkInterfaceDecl(n *InterfaceDecl, v Visitor) {
	Walk(v, n.Name)
	if n.Parent != nil {
		Walk(v, n.Parent)
	}
	for _, method := range n.Methods {
		// Walk interface method children (InterfaceMethodDecl is not a Node)
		Walk(v, method.Name)
		for _, param := range method.Parameters {
			walkParameter(param, v)
		}
		if method.ReturnType != nil {
			Walk(v, method.ReturnType)
		}
	}
}

// walkUnitDeclaration walks a UnitDeclaration node
func walkUnitDeclaration(n *UnitDeclaration, v Visitor) {
	Walk(v, n.Name)
	if n.InterfaceSection != nil {
		Walk(v, n.InterfaceSection)
	}
	if n.ImplementationSection != nil {
		Walk(v, n.ImplementationSection)
	}
	if n.InitSection != nil {
		Walk(v, n.InitSection)
	}
	if n.FinalSection != nil {
		Walk(v, n.FinalSection)
	}
}

// walkUsesClause walks a UsesClause node
func walkUsesClause(n *UsesClause, v Visitor) {
	for _, unit := range n.Units {
		Walk(v, unit)
	}
}

// walkTypeAnnotation walks a TypeAnnotation node
func walkTypeAnnotation(n *TypeAnnotation, v Visitor) {
	if n.InlineType != nil {
		Walk(v, n.InlineType)
	}
}

// walkTypeDeclaration walks a TypeDeclaration node
func walkTypeDeclaration(n *TypeDeclaration, v Visitor) {
	Walk(v, n.Name)
	if n.AliasedType != nil {
		Walk(v, n.AliasedType)
	}
	if n.LowBound != nil {
		Walk(v, n.LowBound)
	}
	if n.HighBound != nil {
		Walk(v, n.HighBound)
	}
	if n.FunctionPointerType != nil {
		Walk(v, n.FunctionPointerType)
	}
}

// walkFunctionPointerTypeNode walks a FunctionPointerTypeNode node
func walkFunctionPointerTypeNode(n *FunctionPointerTypeNode, v Visitor) {
	for _, param := range n.Parameters {
		walkParameter(param, v)
	}
	if n.ReturnType != nil {
		Walk(v, n.ReturnType)
	}
}

// walkAddressOfExpression walks an AddressOfExpression node
func walkAddressOfExpression(n *AddressOfExpression, v Visitor) {
	if n.Operator != nil {
		Walk(v, n.Operator)
	}
	if n.Type != nil {
		Walk(v, n.Type)
	}
}

// walkArrayTypeNode walks an ArrayTypeNode node
func walkArrayTypeNode(n *ArrayTypeNode, v Visitor) {
	if n.LowBound != nil {
		Walk(v, n.LowBound)
	}
	if n.HighBound != nil {
		Walk(v, n.HighBound)
	}
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// walkSetTypeNode walks a SetTypeNode node
func walkSetTypeNode(n *SetTypeNode, v Visitor) {
	if n.ElementType != nil {
		Walk(v, n.ElementType)
	}
}

// Inspect traverses an AST in depth-first order, calling f for each node.
// If f returns false, traversal of that node's children is skipped.
// Otherwise, Inspect is called recursively for each child.
//
// This is a convenience wrapper around Walk for simple inspection tasks.
func Inspect(node Node, f func(Node) bool) {
	Walk(inspector(f), node)
}

// inspector is a helper type that implements Visitor for the Inspect function.
type inspector func(Node) bool

func (f inspector) Visit(node Node) Visitor {
	if f(node) {
		return f
	}
	return nil
}
