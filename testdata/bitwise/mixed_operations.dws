// Mixed bitwise operations with arithmetic
// Tests operator precedence and complex expressions

begin
  // Shifts with arithmetic
  PrintLn('2 + 3 shl 2 = ' + IntToStr(2 + 3 shl 2));  // 2 + (3 << 2) = 2 + 12 = 14
  PrintLn('16 shr 2 + 1 = ' + IntToStr(16 shr 2 + 1));  // (16 >> 2) + 1 = 4 + 1 = 5
  PrintLn('(2 + 3) shl 2 = ' + IntToStr((2 + 3) shl 2));  // 5 << 2 = 20

  // Shifts with bitwise logic
  PrintLn('2 shl 1 or 1 = ' + IntToStr(2 shl 1 or 1));  // (2 << 1) | 1 = 4 | 1 = 5
  PrintLn('(2 shl 1) or 1 = ' + IntToStr((2 shl 1) or 1));  // Same as above
  PrintLn('8 shr 1 and 3 = ' + IntToStr(8 shr 1 and 3));  // (8 >> 1) & 3 = 4 & 3 = 0

  // Practical example: bit masking
  var bitFlags: Integer;
  bitFlags := 0;

  // Set bit 0
  bitFlags := bitFlags or 1;
  PrintLn('After setting bit 0: ' + IntToStr(bitFlags));  // Should be 1

  // Set bit 2
  bitFlags := bitFlags or (1 shl 2);
  PrintLn('After setting bit 2: ' + IntToStr(bitFlags));  // Should be 5 (bits 0 and 2)

  // Test if bit 2 is set
  if (bitFlags and (1 shl 2)) <> 0 then
    PrintLn('Bit 2 is set');

  // Clear bit 0 using XOR
  bitFlags := bitFlags xor 1;
  PrintLn('After clearing bit 0: ' + IntToStr(bitFlags));  // Should be 4

  // Mersenne number calculation (2^p - 1)
  var p, m_p: Integer;
  p := 5;
  m_p := (1 shl p) - 1;
  PrintLn('Mersenne(5) = 2^5 - 1 = ' + IntToStr(m_p));  // Should be 31
end.
