// Simpler quicksort test with size=10

const size = 10;

var swaps: Integer;
type TData = array [0..size - 1] of integer;

procedure ShowData(d: TData);
var x: Integer;
begin
  PrintLn('Data:');
  for x := 0 to size - 1 do
    PrintLn(IntToStr(d[x]));
end;

procedure ShuffleData(var d: TData);
var x, tmp, idxa, idxb: Integer;
begin
  SetRandSeed(0);

  for x := 0 to size - 1 do
    d[x] := x;

  for x := 1 to size do
  begin
    idxa := Trunc(Random() * size);
    idxb := Trunc(Random() * size);
    tmp := d[idxa];
    d[idxa] := d[idxb];
    d[idxb] := tmp;
  end;
end;

function partition (var d: TData; i, j: integer) : integer;
var
  m, tmp: integer;
begin
  m := d[(i + j) div 2];
  PrintLn('Partition pivot=' + IntToStr(m) + ', i=' + IntToStr(i) + ', j=' + IntToStr(j));
  while i < j do
  begin
    while d[i] < m do i := i + 1;
    while d[j] > m do j := j - 1;
    PrintLn('  After while loops: i=' + IntToStr(i) + ', j=' + IntToStr(j) + ', d[i]=' + IntToStr(d[i]) + ', d[j]=' + IntToStr(d[j]));
    if d[i] > d[j] then
    begin
      PrintLn('  Swapping d[' + IntToStr(i) + ']=' + IntToStr(d[i]) + ' with d[' + IntToStr(j) + ']=' + IntToStr(d[j]));
      tmp := d[j];
      d[j] := d[i];
      d[i] := tmp;
      Swaps := Swaps + 1;
    end
    else
      i := j;
  end;
  Result := i;
  PrintLn('Partition returning: ' + IntToStr(Result));
end;

procedure QuickSort(var d: TData; i, j : Integer);
var m : Integer;
begin
  if i < j then
  begin
    PrintLn('QuickSort: i=' + IntToStr(i) + ', j=' + IntToStr(j));
    m := partition (d, i, j);
    quicksort (d, i, m);
    quicksort (d, m + 1, j);
  end;
end;

var data : TData;

ShuffleData(data);
PrintLn('Before sort:');
ShowData(data);

PrintLn('');
PrintLn('Starting QuickSort...');
QuickSort(data, 0, size - 1);

PrintLn('');
PrintLn('After sort:');
Print('Swaps: ');
PrintLn(IntToStr(swaps));
ShowData(data);
