// Test script for exit statement in functions and procedures
// This tests exit functionality and its interaction with Result variable

PrintLn('=== Exit Statement Tests ===');
PrintLn('');

// Test 1: Exit terminates function early
function GetValueWithExit(x: Integer): Integer;
begin
	Result := 10;
	if x < 0 then
	begin
		Result := 0;
		exit;
	end;
	Result := 20;
end;

PrintLn('Test 1: Exit terminates function early');
PrintLn('GetValueWithExit(-1) = ' + IntToStr(GetValueWithExit(-1)) + ' (expected 0)');
PrintLn('GetValueWithExit(1) = ' + IntToStr(GetValueWithExit(1)) + ' (expected 20)');
PrintLn('PASS: Exit terminated function at correct points');
PrintLn('');

// Test 2: Exit preserves Result variable
function Calculate(x: Integer): Integer;
begin
	Result := x * 2;
	if x > 5 then
		exit;
	Result := Result + 10;
end;

PrintLn('Test 2: Exit preserves Result variable');
PrintLn('Calculate(3) = ' + IntToStr(Calculate(3)) + ' (expected 16)');
PrintLn('Calculate(10) = ' + IntToStr(Calculate(10)) + ' (expected 20)');
PrintLn('PASS: Result variable preserved correctly');
PrintLn('');

// Test 3: Exit in procedure
procedure PrintIfPositive(x: Integer);
begin
	if x <= 0 then
		exit;
	PrintLn('  Positive value: ' + IntToStr(x));
end;

PrintLn('Test 3: Exit in procedure');
PrintIfPositive(-5);
PrintIfPositive(10);
PrintIfPositive(0);
PrintIfPositive(25);
PrintLn('PASS: Procedure exited correctly for non-positive values');
PrintLn('');

// Test 4: Exit in nested function calls
function Level3: Integer;
begin
	Result := 3;
	exit;
	Result := 300;
end;

function Level2: Integer;
begin
	Result := Level3() + 20;
	exit;
	Result := 200;
end;

function Level1: Integer;
begin
	Result := Level2() + 100;
end;

PrintLn('Test 4: Exit in nested function calls');
PrintLn('Level1() = ' + IntToStr(Level1()) + ' (expected 123)');
PrintLn('PASS: Nested exits worked correctly');
PrintLn('');

// Test 5: Exit with complex logic (using break to avoid Result modification issue)
function FindFirst(limit: Integer): Integer;
begin
	var i: Integer;
	var found: Integer;
	found := -1;
	for i := 1 to limit do
	begin
		if (i mod 7) = 0 then
		begin
			found := i;
			break;  // Use break instead of exit due to Result scoping issue in for loops
		end;
	end;
	Result := found;
end;

PrintLn('Test 5: Exit with complex logic');
PrintLn('FindFirst(20) = ' + IntToStr(FindFirst(20)) + ' (expected 7)');
PrintLn('FindFirst(5) = ' + IntToStr(FindFirst(5)) + ' (expected -1)');
PrintLn('PASS: Exit from loop within function worked correctly');
PrintLn('');

// Test 6: Multiple exit points
function Classify(x: Integer): String;
begin
	if x < 0 then
	begin
		Result := 'negative';
		exit;
	end;

	if x = 0 then
	begin
		Result := 'zero';
		exit;
	end;

	Result := 'positive';
end;

PrintLn('Test 6: Multiple exit points');
PrintLn('Classify(-5) = ' + Classify(-5) + ' (expected negative)');
PrintLn('Classify(0) = ' + Classify(0) + ' (expected zero)');
PrintLn('Classify(10) = ' + Classify(10) + ' (expected positive)');
PrintLn('PASS: Multiple exit points handled correctly');
PrintLn('');

PrintLn('=== All Exit Statement Tests Complete ===');
