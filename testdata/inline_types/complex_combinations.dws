// Test complex combinations of inline types
// Arrays of function pointers, function pointers returning arrays, etc.

// Function that accepts array of function pointers
procedure CallAll(handlers: array of procedure(msg: String));
var
  i: Integer;
begin
  for i := 0 to High(handlers) do
    handlers[i]('Message ' + IntToStr(i));
end;

// Variable: array of function pointers
var operations: array of function(x: Integer): Integer;

// Simple operations
function Inc(x: Integer): Integer;
begin
  Result := x + 1;
end;

function Dec(x: Integer): Integer;
begin
  Result := x - 1;
end;

function Sq(x: Integer): Integer;
begin
  Result := x * x;
end;

// ===== NEW: Functions returning arrays of function pointers =====

function GetTransformers(): array of function(x: Integer): Integer;
begin
  var result: array of function(x: Integer): Integer;
  SetLength(result, 2);
  result[0] := @Inc;
  result[1] := @Sq;
  Result := result;
end;

// ===== NEW: Function accepting array and returning array =====

function ApplyOperations(values: array of Integer; ops: array of function(x: Integer): Integer): array of Integer;
begin
  var i: Integer;
  var j: Integer;
  var result: array of Integer;
  SetLength(result, Length(values) * Length(ops));

  var idx: Integer := 0;
  for i := 0 to High(values) do
    for j := 0 to High(ops) do begin
      result[idx] := ops[j](values[i]);
      idx := idx + 1;
    end;

  Result := result;
end;

// ===== NEW: Function taking array parameter with inline type and returning array =====

function ProcessWithFunctions(data: array[1..3] of Integer; transform: function(x: Integer): Integer): array[1..3] of Integer;
begin
  var i: Integer;
  var result: array[1..3] of Integer;
  for i := 1 to 3 do
    result[i] := transform(data[i]);
  Result := result;
end;

// ===== NEW: Static array of function pointers =====
// Note: Type aliases with inline function pointers not yet fully supported
// Using direct inline type in return instead

function CreateStaticOpArray(): array[1..3] of function(x: Integer): Integer;
begin
  var result: array[1..3] of function(x: Integer): Integer;
  result[1] := @Inc;
  result[2] := @Dec;
  result[3] := @Sq;
  Result := result;
end;

begin
  PrintLn('=== Complex Inline Type Combinations Test ===');
  PrintLn('');

  // Test 1: Basic array of function pointers
  PrintLn('Test 1: Array of function pointers');
  SetLength(operations, 3);
  operations[0] := @Inc;
  operations[1] := @Dec;
  operations[2] := @Sq;

  PrintLn('Inc(5): ' + IntToStr(operations[0](5)));   // 6
  PrintLn('Dec(5): ' + IntToStr(operations[1](5)));   // 4
  PrintLn('Sq(5): ' + IntToStr(operations[2](5)));    // 25
  PrintLn('');

  // Test 2: Function returning array of function pointers
  PrintLn('Test 2: Function returning array of function pointers');
  var transformers: array of function(x: Integer): Integer := GetTransformers();
  PrintLn('Got ' + IntToStr(Length(transformers)) + ' transformers');
  PrintLn('Transformer[0](10): ' + IntToStr(transformers[0](10)));  // 11
  PrintLn('Transformer[1](10): ' + IntToStr(transformers[1](10)));  // 100
  PrintLn('');

  // Test 3: Function taking and returning arrays with function pointers
  PrintLn('Test 3: Function taking and returning arrays');
  var inputVals: array of Integer;
  SetLength(inputVals, 2);
  inputVals[0] := 3;
  inputVals[1] := 5;

  var ops: array of function(x: Integer): Integer;
  SetLength(ops, 2);
  ops[0] := @Inc;
  ops[1] := @Sq;

  var results: array of Integer := ApplyOperations(inputVals, ops);
  PrintLn('Applied ' + IntToStr(Length(ops)) + ' ops to ' + IntToStr(Length(inputVals)) + ' values');
  PrintLn('Results count: ' + IntToStr(Length(results)));
  PrintLn('results[0] = Inc(3) = ' + IntToStr(results[0]));  // 4
  PrintLn('results[1] = Sq(3) = ' + IntToStr(results[1]));   // 9
  PrintLn('results[2] = Inc(5) = ' + IntToStr(results[2]));  // 6
  PrintLn('results[3] = Sq(5) = ' + IntToStr(results[3]));   // 25
  PrintLn('');

  // Test 4: Static array of function pointers with inline return type
  PrintLn('Test 4: Static array of function pointers');
  var staticOps: array[1..3] of function(x: Integer): Integer := CreateStaticOpArray();
  PrintLn('staticOps[1](7) = Inc(7) = ' + IntToStr(staticOps[1](7)));  // 8
  PrintLn('staticOps[2](7) = Dec(7) = ' + IntToStr(staticOps[2](7)));  // 6
  PrintLn('staticOps[3](7) = Sq(7) = ' + IntToStr(staticOps[3](7)));   // 49
  PrintLn('');

  // Test 5: Process static array with function parameter
  PrintLn('Test 5: Process static array with function parameter');
  var staticData: array[1..3] of Integer;
  staticData[1] := 2;
  staticData[2] := 3;
  staticData[3] := 4;

  var transformed: array[1..3] of Integer := ProcessWithFunctions(staticData, @Sq);
  PrintLn('Transformed[1] = Sq(2) = ' + IntToStr(transformed[1]));  // 4
  PrintLn('Transformed[2] = Sq(3) = ' + IntToStr(transformed[2]));  // 9
  PrintLn('Transformed[3] = Sq(4) = ' + IntToStr(transformed[3]));  // 16

  PrintLn('');
  PrintLn('=== All complex combination tests completed successfully! ===');
end.
